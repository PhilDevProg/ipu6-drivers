diff --git a/drivers/platform/x86/intel/int3472/clk_and_regulator.c b/drivers/platform/x86/intel/int3472/clk_and_regulator.c
index 74dc2cff799e..fd4df039093f 100644
--- a/drivers/platform/x86/intel/int3472/clk_and_regulator.c
+++ b/drivers/platform/x86/intel/int3472/clk_and_regulator.c
@@ -11,6 +11,14 @@
 
 #include "common.h"
 
+/*
+ * 82c0d13a-78c5-4244-9bb1-eb8b539a8d11
+ * This _DSM GUID calls CLKC and CLKF.
+ */
+static const guid_t clock_ctrl_guid =
+	GUID_INIT(0x82c0d13a, 0x78c5, 0x4244,
+		  0x9b, 0xb1, 0xeb, 0x8b, 0x53, 0x9a, 0x8d, 0x11);
+
 /*
  * The regulators have to have .ops to be valid, but the only ops we actually
  * support are .enable and .disable which are handled via .ena_gpiod. Pass an
@@ -21,9 +29,40 @@ static const struct regulator_ops int3472_gpio_regulator_ops;
 static int skl_int3472_clk_prepare(struct clk_hw *hw)
 {
 	struct int3472_gpio_clock *clk = to_int3472_clk(hw);
+	struct int3472_discrete_device *int3472 = to_int3472_device(clk);
+	union acpi_object clock_args[] = {
+		{
+			.integer = {
+				.type = ACPI_TYPE_INTEGER,
+				.value = clk->imgclk_index,
+			}
+		},
+		{
+			.integer = {
+				.type = ACPI_TYPE_INTEGER,
+				.value = 0x01,
+			}
+		},
+		{
+			.integer = {
+				.type = ACPI_TYPE_INTEGER,
+				.value = 0x01,
+			}
+		},
+	};
+	union acpi_object clock_ctrl_args = {
+		.package = {
+			.type = ACPI_TYPE_PACKAGE,
+			.count = 3,
+			.elements = clock_args,
+		},
+	};
 
 	gpiod_set_value_cansleep(clk->ena_gpio, 1);
 	gpiod_set_value_cansleep(clk->led_gpio, 1);
+	acpi_evaluate_dsm(acpi_device_handle(int3472->adev),
+			  &clock_ctrl_guid, 0x00, 0x01,
+			  &clock_ctrl_args);
 
 	return 0;
 }
@@ -31,7 +70,38 @@ static int skl_int3472_clk_prepare(struct clk_hw *hw)
 static void skl_int3472_clk_unprepare(struct clk_hw *hw)
 {
 	struct int3472_gpio_clock *clk = to_int3472_clk(hw);
+	struct int3472_discrete_device *int3472 = to_int3472_device(clk);
+	union acpi_object clock_args[] = {
+		{
+			.integer = {
+				.type = ACPI_TYPE_INTEGER,
+				.value = clk->imgclk_index,
+			}
+		},
+		{
+			.integer = {
+				.type = ACPI_TYPE_INTEGER,
+				.value = 0,
+			}
+		},
+		{
+			.integer = {
+				.type = ACPI_TYPE_INTEGER,
+				.value = 0x01,
+			}
+		},
+	};
+	union acpi_object clock_ctrl_args = {
+		.package = {
+			.type = ACPI_TYPE_PACKAGE,
+			.count = 3,
+			.elements = clock_args,
+		},
+	};
 
+	acpi_evaluate_dsm(acpi_device_handle(int3472->adev),
+			  &clock_ctrl_guid, 0x00, 0x01,
+			  &clock_ctrl_args);
 	gpiod_set_value_cansleep(clk->ena_gpio, 0);
 	gpiod_set_value_cansleep(clk->led_gpio, 0);
 }
diff --git a/drivers/platform/x86/intel/int3472/common.h b/drivers/platform/x86/intel/int3472/common.h
index 53270d19c73a..f7a5956876e8 100644
--- a/drivers/platform/x86/intel/int3472/common.h
+++ b/drivers/platform/x86/intel/int3472/common.h
@@ -61,7 +61,9 @@ struct int3472_cldb {
 	u8 control_logic_type;
 	u8 control_logic_id;
 	u8 sensor_card_sku;
-	u8 reserved[28];
+	u8 reserved[10];
+	u8 clock_source;
+	u8 reserved_2[17];
 };
 
 struct int3472_gpio_function_remap {
@@ -98,6 +100,7 @@ struct int3472_discrete_device {
 		struct gpio_desc *ena_gpio;
 		struct gpio_desc *led_gpio;
 		u32 frequency;
+		u8 imgclk_index;
 	} clock;
 
 	unsigned int ngpios; /* how many GPIOs have we seen */
diff --git a/drivers/platform/x86/intel/int3472/discrete.c b/drivers/platform/x86/intel/int3472/discrete.c
index c42c3faa2c32..120cf63b2cdb 100644
--- a/drivers/platform/x86/intel/int3472/discrete.c
+++ b/drivers/platform/x86/intel/int3472/discrete.c
@@ -62,6 +62,7 @@ static const struct int3472_sensor_config int3472_sensor_configs[] = {
 	{ "GEFF150023R", REGULATOR_SUPPLY("avdd", NULL), NULL },
 	/* Surface Go 1&2 - OV5693, Front */
 	{ "YHCU", REGULATOR_SUPPLY("avdd", NULL), NULL },
+	{ "09B13", REGULATOR_SUPPLY("vcc", NULL), NULL },
 };
 
 static const struct int3472_sensor_config *
@@ -314,20 +315,9 @@ static int skl_int3472_parse_crs(struct int3472_discrete_device *int3472)
 
 	acpi_dev_free_resource_list(&resource_list);
 
-	/*
-	 * If we find no clock enable GPIO pin then the privacy LED won't work.
-	 * We've never seen that situation, but it's possible. Warn the user so
-	 * it's clear what's happened.
-	 */
-	if (int3472->clock.ena_gpio) {
-		ret = skl_int3472_register_clock(int3472);
-		if (ret)
-			return ret;
-	} else {
-		if (int3472->clock.led_gpio)
-			dev_warn(int3472->dev,
-				 "No clk GPIO. The privacy LED won't work\n");
-	}
+	ret = skl_int3472_register_clock(int3472);
+	if (ret)
+		return ret;
 
 	int3472->gpios.dev_id = int3472->sensor_name;
 	gpiod_add_lookup_table(&int3472->gpios);
@@ -380,6 +370,7 @@ static int skl_int3472_discrete_probe(struct platform_device *pdev)
 	int3472->adev = adev;
 	int3472->dev = &pdev->dev;
 	platform_set_drvdata(pdev, int3472);
+	int3472->clock.imgclk_index = cldb.clock_source;
 
 	ret = skl_int3472_get_sensor_adev_and_name(&pdev->dev, &int3472->sensor,
 						   &int3472->sensor_name);

